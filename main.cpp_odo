#include <stdio.h>
#include <string.h>
#include <math.h>
#include <atomic>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "driver/gpio.h"
#include <driver/rtc_io.h>
#include "esp_timer.h"
#include "esp_log.h"
#include "esp_sleep.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <LovyanGFX.hpp>
#include "displaytft.h"

//static LGFX lcd;

// --- Konfiguráció ---
#define REED_SWITCH_PIN     GPIO_NUM_32
#define BUTTON_PIN          GPIO_NUM_0  // Ébresztő gomb IO0-n
#define RESET_DAILY_BTN_PIN GPIO_NUM_35 // Napi út nullázó gomb (!! Külső PULL-UP szükséges !!)
#define WHEEL_DIAMETER_M    0.348        // Kerék átmérője méterben (!! FONTOS: Állítsd be a valós értéket !!)
#define PULSES_PER_REVOLUTION 1         // Impulzusok száma egy teljes kerékfordulat alatt

#define REPORTING_INTERVAL_MS 1000      // Adatküldés, számítás gyakorisága (1 mp)
#define INACTIVITY_TIMEOUT_S  (2 * 60) // Inaktivitási időkorlát másodpercben (30 perc)
#define INACTIVITY_TIMEOUT_US (INACTIVITY_TIMEOUT_S * 1000000ULL)
#define NVS_SAVE_INTERVAL_MS (15 * 60 * 1000) // NVS mentési intervallum (15 perc)
#define RESET_BUTTON_HOLD_TIME_MS 1000    // Napi számláló nullázásához nyomva tartás ideje
#define RESET_BUTTON_POLL_INTERVAL_MS 50  // Napi nullázó gomb figyelési gyakorisága

// --- Szimulációs Konfiguráció ---
#define SIMULATE_REED_INPUT 1       // 1 = Szimuláció aktív, 0 = Szimuláció inaktív
#define SIMULATED_SPEED_KMH 20.0     // Szimulált sebesség km/h-ban
#define SIMULATION_DURATION_MINUTES 1 // Szimuláció időtartama percben (csak szimulációhoz)

// --- Globális Változók (szálbiztos) ---
std::atomic<uint64_t> pulseCount(0);        // Teljes impulzusszám (induláskor NVS-ből töltődik)
std::atomic<int64_t> lastPulseTimeUs(0);    // Utolsó REED impulzus ideje mikroszekundumban

// --- RTC Memória Változók ---
// Ezek megőrzik értéküket mélyalvás alatt, de teljes tápmegszakításkor elvesznek/meghatározatlanok
RTC_DATA_ATTR uint64_t dailyTripStartPulseCount = 0; // Az a pulseCount érték, ahonnan a napi út számítása indul
RTC_DATA_ATTR uint16_t bootCount;

// --- Struktúra a megosztott adatokhoz ---
/*typedef struct {
    double speedKmh;
    double dailyDistanceKm;
    double totalDistanceKm;
} SensorData_t;*/

// --- Globális változók (mutex-szel védett) ---
SensorData_t sharedSensorData = {0.0, 0.0, 0.0}; // Kezdeti értékek
SemaphoreHandle_t xDataMutex = NULL;       // Mutex a sharedSensorData védelmére

// --- NVS Globálisok ---
#define NVS_NAMESPACE "storage"
#define NVS_KEY_TOTAL_PULSES "total_pulses"
nvs_handle_t g_nvs_handle = 0; // NVS handle (globális, hogy ne kelljen mindenhol nyitni/zárni)

const char *TAG = "WheelSensorV3"; // Logoláshoz TAG

// --- Prototípusok ---
void go_to_deep_sleep(void);
esp_err_t init_nvs(void);
esp_err_t load_total_pulses_from_nvs(uint64_t *pulses);
esp_err_t save_total_pulses_to_nvs(uint64_t pulses);
void reset_button_monitor_task(void *pvParameters);
void reed_simulation_task(void *pvParameters);

volatile int64_t lastDebounceTimeUs = 0;
const int64_t debounceDelayUs = 10000; // 10 ms

// --- ISR (Interrupt Service Routine - REED) ---
static void IRAM_ATTR gpio_isr_handler(void* arg) {
    int64_t currentTimeUs_isr = esp_timer_get_time();

    if ((currentTimeUs_isr - lastDebounceTimeUs) > debounceDelayUs) { // (1) Feltétel ellenőrzése
        pulseCount.fetch_add(1, std::memory_order_relaxed);          // (2) pulseCount növelése
        lastPulseTimeUs.store(currentTimeUs_isr, std::memory_order_relaxed); // (3) Utolsó impulzus idejének rögzítése
        lastDebounceTimeUs = currentTimeUs_isr;                      // (4) lastDebounceTimeUs frissítése
    }
}

// --- NVS Mentő Task ---
void nvs_save_task(void *pvParameters) {
    ESP_LOGI(TAG, "NVS save task started. Saving every %d minutes.", NVS_SAVE_INTERVAL_MS / (60 * 1000));
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(NVS_SAVE_INTERVAL_MS));

        uint64_t currentTotalPulses = pulseCount.load(std::memory_order_relaxed);
        esp_err_t err = save_total_pulses_to_nvs(currentTotalPulses);
        if (err == ESP_OK) {
            ESP_LOGI(TAG, "Total pulses (%llu) saved to NVS.", currentTotalPulses);
        } else {
            ESP_LOGE(TAG, "Failed to save total pulses to NVS!");
        }
    }
}

// --- Sebesség/Távolság Számoló és Alvásvezérlő Task ---
void calculation_and_control_task(void *pvParameters) {
    ESP_LOGI(TAG, "Calculation and control task started.");

    const int64_t systemOrTaskStartTimeUs = esp_timer_get_time(); // Rendszer/task indulási ideje
    uint64_t previousTotalPulseCountForCalc = pulseCount.load(std::memory_order_relaxed);
    int64_t lastCheckTimeUs = systemOrTaskStartTimeUs;

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(REPORTING_INTERVAL_MS));

        int64_t currentTimeUs = esp_timer_get_time();
        uint64_t currentTotalPulses = pulseCount.load(std::memory_order_relaxed);
        int64_t latestReedPulseTime = lastPulseTimeUs.load(std::memory_order_relaxed);

        // Napi út számítása
        uint64_t current_daily_raw_pulses = 0;
        uint64_t rtc_daily_start = dailyTripStartPulseCount; // Olvassuk ki az RTC változót
        if (currentTotalPulses >= rtc_daily_start) {
            current_daily_raw_pulses = currentTotalPulses - rtc_daily_start;
        }
        // Ha valamiért a currentTotalPulses kisebb lenne (pl. NVS hiba után), akkor 0

        // Impulzusok száma az utolsó intervallumban a sebességhez
        uint64_t pulsesInInterval = currentTotalPulses - previousTotalPulseCountForCalc;
        double deltaTimeS = (double)(currentTimeUs - lastCheckTimeUs) / 1000000.0;

        // Sebesség számítása
        double currentSpeedKmh = 0.0;
        if (pulsesInInterval > 0 && deltaTimeS > 0.01) { // Kerüljük a 0-val osztást vagy túl kicsi dt-t
            double revolutionsInInterval = (double)pulsesInInterval / PULSES_PER_REVOLUTION;
            double distanceMetersInInterval = revolutionsInInterval * (M_PI * WHEEL_DIAMETER_M);
            double speedMps = distanceMetersInInterval / deltaTimeS;
            currentSpeedKmh = speedMps * 3.6;
        }

        // Megállás detektálása (ha az utolsó impulzus régen volt)
        // Figyelem: latestReedPulseTime lehet 0, ha még nem volt impulzus
        if (latestReedPulseTime != 0 && (currentTimeUs - latestReedPulseTime) > 3000000ULL) { // 3 másodperc
             currentSpeedKmh = 0.0;
        }
         // Ha még egyáltalán nem jött impulzus a start óta, és a pulseCount sem változott (NVS-ből töltött)
        if (latestReedPulseTime == 0 && currentTotalPulses == previousTotalPulseCountForCalc) {
             currentSpeedKmh = 0.0;
        }


        // Távolságok kiszámítása km-ben
        double currentDailyDistanceKm = ((double)current_daily_raw_pulses / PULSES_PER_REVOLUTION) * (M_PI * WHEEL_DIAMETER_M) / 1000.0;
        double currentTotalDistanceKm = ((double)currentTotalPulses / PULSES_PER_REVOLUTION) * (M_PI * WHEEL_DIAMETER_M) / 1000.0;

        // Adatok frissítése (Mutex védelemmel)
        if (xSemaphoreTake(xDataMutex, pdMS_TO_TICKS(50)) == pdTRUE) {
            sharedSensorData.speedKmh = currentSpeedKmh;
            sharedSensorData.dailyDistanceKm = currentDailyDistanceKm;
            sharedSensorData.totalDistanceKm = currentTotalDistanceKm;
            xSemaphoreGive(xDataMutex);
        } else {
            ESP_LOGW(TAG, "Calculation task couldn't get mutex for shared data!");
        }

        // Előző értékek frissítése a következő ciklushoz
        previousTotalPulseCountForCalc = currentTotalPulses;
        lastCheckTimeUs = currentTimeUs;

        // --- Inaktivitás ellenőrzése és Mélyalvás indítása ---
        int64_t referenceTimeForInactivity;
        if (latestReedPulseTime != 0) { // Ha volt már REED impulzus
            referenceTimeForInactivity = latestReedPulseTime;
        } else { // Ha még nem volt REED impulzus ebben a működési ciklusban
            referenceTimeForInactivity = systemOrTaskStartTimeUs;
        }

        if ((currentTimeUs - referenceTimeForInactivity) > INACTIVITY_TIMEOUT_US) {
            ESP_LOGI(TAG, "Inactivity timeout reached (Reference: %s). Entering deep sleep.",
                     (latestReedPulseTime != 0) ? "last REED pulse" : "system start");
            
            // Mielőtt aludni megyünk, mentsük el az aktuális teljes impulzusszámot
            esp_err_t err = save_total_pulses_to_nvs(currentTotalPulses);
            if (err == ESP_OK) {
                ESP_LOGI(TAG, "Final total pulses (%llu) saved to NVS before sleep.", currentTotalPulses);
            } else {
                ESP_LOGE(TAG, "Failed to save final total pulses to NVS before sleep!");
            }
            // A dailyTripStartPulseCount már RTC, nem kell külön menteni alvás előtt
            go_to_deep_sleep(); // Ez a függvény nem tér vissza
        }
    }
}

// --- Soros Portra Küldő Task ---
void serial_output_task(void *pvParameters) {
    ESP_LOGI(TAG, "Serial output task started.");
    uint64_t local_daily_trip_start_pulses;
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(REPORTING_INTERVAL_MS));
        SensorData_t dataToPrint;

        local_daily_trip_start_pulses = dailyTripStartPulseCount; // Olvassuk ki az RTC változót
        uint64_t current_total_p = pulseCount.load(std::memory_order_relaxed);
        uint64_t current_daily_p = 0;
        if (current_total_p >= local_daily_trip_start_pulses) {
             current_daily_p = current_total_p - local_daily_trip_start_pulses;
        }


        if (xSemaphoreTake(xDataMutex, pdMS_TO_TICKS(50)) == pdTRUE) {
            dataToPrint = sharedSensorData;
            xSemaphoreGive(xDataMutex);
            // A printf-ben a daily távolságot a sharedSensorData-ból vesszük, de a pulse count-okat frissen számoljuk
            //printf("Speed: %.2f km/h, Daily: %.3f km, Total: %.3f km | TP: %llu, DSP: %llu, CDP: %llu\n",
            ESP_LOGI(TAG, "Speed: %.2f km/h, Daily: %.2f km, Total: %.2f km | TP: %llu, DSP: %llu, CDP: %llu",
                   dataToPrint.speedKmh,
                   dataToPrint.dailyDistanceKm,
                   dataToPrint.totalDistanceKm,
                   current_total_p,
                   local_daily_trip_start_pulses,
                   current_daily_p);
        } else {
            ESP_LOGW(TAG, "Serial task couldn't get mutex for printing!");
        }
    }
}

// --- Napi Út Nullázó Gomb Figyelő Task ---
void reset_button_monitor_task(void *pvParameters) {
    ESP_LOGI(TAG, "Reset button monitor task started (GPIO%d).", RESET_DAILY_BTN_PIN);

    TickType_t button_press_start_time = 0;
    bool button_currently_pressed = false;
    bool reset_action_taken_this_press = false;

    while(1) {
        vTaskDelay(pdMS_TO_TICKS(RESET_BUTTON_POLL_INTERVAL_MS));

        int button_state = gpio_get_level(RESET_DAILY_BTN_PIN);

        if (button_state == 0) { // Gomb lenyomva (LOW)
            if (!button_currently_pressed) { // Éppen most nyomták le
                button_currently_pressed = true;
                button_press_start_time = xTaskGetTickCount();
                reset_action_taken_this_press = false;
                ESP_LOGD(TAG, "Reset button (GPIO%d) pressed down.", RESET_DAILY_BTN_PIN);
            }

            if (button_currently_pressed && !reset_action_taken_this_press) {
                if ((xTaskGetTickCount() - button_press_start_time) * portTICK_PERIOD_MS >= RESET_BUTTON_HOLD_TIME_MS) {
                    ESP_LOGI(TAG, "Reset daily distance button held. Resetting daily counter.");
                    
                    uint64_t current_total_pulses_for_reset = pulseCount.load(std::memory_order_relaxed);
                    dailyTripStartPulseCount = current_total_pulses_for_reset; // RTC változó írása
                    ESP_LOGI(TAG, "Daily trip start pulse count set to: %llu", dailyTripStartPulseCount);

                    if (xSemaphoreTake(xDataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                        sharedSensorData.dailyDistanceKm = 0.0;
                        xSemaphoreGive(xDataMutex);
                        ESP_LOGI(TAG, "Shared daily distance immediately updated to 0 km.");
                    } else {
                        ESP_LOGW(TAG, "Reset task failed to get mutex for shared data update!");
                    }
                    reset_action_taken_this_press = true;
                }
            }
        } else { // Gomb felengedve (HIGH)
            if (button_currently_pressed) {
                ESP_LOGD(TAG, "Reset button (GPIO%d) released.", RESET_DAILY_BTN_PIN);
                button_currently_pressed = false;
                reset_action_taken_this_press = false;
            }
        }
    }
}


// --- NVS Funkciók ---
esp_err_t init_nvs(void) {
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS partition was truncated or new version found, erasing and reinitializing...");
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "NVS initialized successfully.");
        // Globális NVS handle megnyitása itt, ha még nincs megnyitva
        if (g_nvs_handle == 0) { // Csak akkor nyissuk meg, ha még nincs
            esp_err_t open_err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &g_nvs_handle);
            if (open_err != ESP_OK) {
                ESP_LOGE(TAG, "Error (%s) opening NVS handle in init_nvs!", esp_err_to_name(open_err));
                // Itt lehetne jelezni a hibát, pl. egy globális flaggel, hogy az NVS nem használható
            } else {
                ESP_LOGI(TAG, "NVS handle opened successfully in init_nvs.");
            }
        }
    }
    return ret;
}

esp_err_t load_total_pulses_from_nvs(uint64_t *pulses) {
    if (g_nvs_handle == 0) {
        ESP_LOGE(TAG, "NVS handle not open in load_total_pulses_from_nvs. Attempting to open...");
        // Próbáljuk meg itt is megnyitni, ha valamiért nem sikerült az init_nvs-ben, vagy az init_nvs nem nyitotta meg
        esp_err_t open_err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &g_nvs_handle);
        if (open_err != ESP_OK) {
            ESP_LOGE(TAG, "Failed to open NVS handle in load: %s. Returning error.", esp_err_to_name(open_err));
            *pulses = 0; // Hiba esetén 0-val térünk vissza, mintha nem lenne mentett érték
            return open_err; // Visszatérünk a hibakóddal
        }
    }

    esp_err_t err = nvs_get_u64(g_nvs_handle, NVS_KEY_TOTAL_PULSES, pulses);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGI(TAG, "NVS key '%s' not found. Initializing with 0.", NVS_KEY_TOTAL_PULSES);
        *pulses = 0;
        // És el is mentjük a nullát, hogy legközelebb meglegyen
        esp_err_t save_err = nvs_set_u64(g_nvs_handle, NVS_KEY_TOTAL_PULSES, *pulses);
         if (save_err != ESP_OK) {
             ESP_LOGE(TAG, "Failed to save initial NVS value: %s", esp_err_to_name(save_err));
         } else {
            save_err = nvs_commit(g_nvs_handle);
            if (save_err != ESP_OK) ESP_LOGE(TAG, "Failed to commit initial NVS value: %s", esp_err_to_name(save_err));
         }
        err = ESP_OK; // Visszaadjuk, hogy a betöltés sikeres volt (0-val)
    } else if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) reading NVS key '%s'! Defaulting to 0.", esp_err_to_name(err), NVS_KEY_TOTAL_PULSES);
        *pulses = 0; // Hiba esetén is 0-val térjünk vissza
    } else {
        ESP_LOGI(TAG, "Loaded total pulses from NVS: %llu", *pulses);
    }
    // A handle-t nyitva hagyjuk
    return err;
}

esp_err_t save_total_pulses_to_nvs(uint64_t pulses) {
    if (g_nvs_handle == 0) {
        ESP_LOGE(TAG, "NVS handle not open in save_total_pulses_to_nvs. Cannot save.");
        // Ideális esetben az init_nvs már megnyitotta. Ha nem, itt hiba van.
        // Lehetne próbálkozni a nyitással, de ha az initben nem sikerült, itt sem fog valószínűleg.
        return ESP_FAIL; // Vagy egy specifikusabb hibakód
    }

    esp_err_t err = nvs_set_u64(g_nvs_handle, NVS_KEY_TOTAL_PULSES, pulses);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) writing NVS key '%s'!", esp_err_to_name(err), NVS_KEY_TOTAL_PULSES);
        return err;
    }
    err = nvs_commit(g_nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) committing NVS changes!", esp_err_to_name(err));
    }
    return err;
}


// --- Mélyalvás Indítása ---
void go_to_deep_sleep(void) {
    ESP_LOGI(TAG, "Preparing for deep sleep...");

    // NVS handle bezárása alvás előtt, ha nyitva van
    if (g_nvs_handle) {
        nvs_close(g_nvs_handle);
        g_nvs_handle = 0; // Handle nullázása, hogy az init_nvs újra megnyissa ébredéskor
        ESP_LOGI(TAG, "NVS handle closed before sleep.");
    } else {
        ESP_LOGW(TAG, "NVS handle was not open (or already closed) before sleep.");
    }
    //bootCount++;
    ESP_LOGI(TAG, "Configuring wake up sources...");
    esp_sleep_enable_ext0_wakeup(BUTTON_PIN, 0); // Gomb (GPIO0)
    const uint64_t ext1_wakeup_pin_mask = 1ULL << REED_SWITCH_PIN; // REED (GPIO32)
    esp_sleep_enable_ext1_wakeup(ext1_wakeup_pin_mask, ESP_EXT1_WAKEUP_ALL_LOW);

    ESP_LOGI(TAG, "Entering deep sleep now.");
    fflush(stdout); // Biztosítjuk, hogy minden log kimenjen
    //uart_tx_wait_idle(CONFIG_ESP_CONSOLE_UART_NUM); // Várjuk meg, míg az UART kiír mindent
    // A deep sleep előtt érdemes megvárni, hogy a TFT kiírja az utolsó üzeneteket  
    lcd.setTextColor(TFT_WHITE, TFT_BLUE);
    vTaskDelay(pdMS_TO_TICKS(10)); // Várunk egy kicsit
    esp_deep_sleep_start(); 
    
    // A program innen már nem folytatódik, csak ébredés után újraindul az app_main-től
}

/*
// --- REED Szimulációs Task ---
void reed_simulation_task(void *pvParameters) {
  ESP_LOGI(TAG, "REED Simulation Task started. Simulating %.1f km/h.",
           SIMULATED_SPEED_KMH);

  if (SIMULATED_SPEED_KMH <= 0) {
    ESP_LOGW(TAG, "Simulated speed is 0 or negative. Simulation task will not "
                  "generate pulses.");
    vTaskDelete(NULL); // Task törlése, ha nincs mit szimulálni
    return;
  }

  // Számítások a szimulációhoz
  const double speed_mps = SIMULATED_SPEED_KMH / 3.6;
  const double wheel_circumference_m = M_PI * WHEEL_DIAMETER_M;
  const double revolutions_per_sec = speed_mps / wheel_circumference_m;
  const double pulses_per_sec = revolutions_per_sec * PULSES_PER_REVOLUTION;

  if (pulses_per_sec <= 0) {
    ESP_LOGW(TAG, "Calculated pulses_per_sec is 0 or negative. Simulation task "
                  "will not generate pulses.");
    vTaskDelete(NULL);
    return;
  }

  const uint32_t delay_between_pulses_ms =
      (uint32_t)((1.0 / pulses_per_sec) * 1000.0);

  if (delay_between_pulses_ms == 0) {
    ESP_LOGW(TAG, "Delay between pulses is 0 (speed too high for discrete "
                  "simulation pulses at this resolution or config error). Task "
                  "stopping.");
    vTaskDelete(NULL);
    return;
  }

  ESP_LOGI(TAG, "Simulation details: Speed: %.2f m/s, Circumference: %.3f m, "
                "RPS: %.3f, PPS: %.3f, Delay: %lu ms",
           speed_mps, wheel_circumference_m, revolutions_per_sec,
           pulses_per_sec, delay_between_pulses_ms);

  while (1) {
    vTaskDelay(pdMS_TO_TICKS(delay_between_pulses_ms));

    // Szimuláljuk az ISR működését
    pulseCount.fetch_add(1, std::memory_order_relaxed);
    lastPulseTimeUs.store(esp_timer_get_time(), std::memory_order_relaxed);

    // Opcionális logolás minden generált impulzusnál (sok lehet, óvatosan vele)
    // ESP_LOGD(TAG, "Simulated pulse generated. pulseCount: %llu",
    // pulseCount.load(std::memory_order_relaxed));
  }
}*/
// --- REED Szimulációs Task ---
void reed_simulation_task(void *pvParameters) {
  ESP_LOGI(TAG,
           "REED Simulation Task started. Simulating %.1f km/h for %d minutes.",
           SIMULATED_SPEED_KMH, SIMULATION_DURATION_MINUTES);

  if (SIMULATED_SPEED_KMH <= 0 || SIMULATION_DURATION_MINUTES <= 0) {
    ESP_LOGW(TAG, "Simulated speed or duration is 0 or negative. Simulation "
                  "task stopping.");
    vTaskDelete(NULL);
    return;
  }

  // Számítások a szimulációhoz
  const double speed_mps = SIMULATED_SPEED_KMH / 3.6;
  const double wheel_circumference_m = M_PI * WHEEL_DIAMETER_M;
  const double revolutions_per_sec = speed_mps / wheel_circumference_m;
  const double pulses_per_sec = revolutions_per_sec * PULSES_PER_REVOLUTION;

  if (pulses_per_sec <= 0) {
    ESP_LOGW(TAG, "Calculated pulses_per_sec is 0 or negative. Simulation task "
                  "stopping.");
    vTaskDelete(NULL);
    return;
  }

  const uint32_t delay_between_pulses_ms =
      (uint32_t)((1.0 / pulses_per_sec) * 1000.0);

  if (delay_between_pulses_ms == 0) {
    ESP_LOGW(TAG, "Delay between pulses is 0 (speed too high or config error). "
                  "Task stopping.");
    vTaskDelete(NULL);
    return;
  }

  ESP_LOGI(TAG, "Simulation details: Speed: %.2f m/s, Circumference: %.3f m, "
                "RPS: %.3f, PPS: %.3f, Delay: %lu ms",
           speed_mps, wheel_circumference_m, revolutions_per_sec,
           pulses_per_sec, delay_between_pulses_ms);

  const int64_t simulation_start_time_us = esp_timer_get_time();
  const int64_t simulation_duration_us = (int64_t)SIMULATION_DURATION_MINUTES *
                                         60 * 1000 * 1000; // Mikroszekundumban

  while (1) {
    // Ellenőrizzük, hogy lejárt-e a szimulációs idő
    if ((esp_timer_get_time() - simulation_start_time_us) >=
        simulation_duration_us) {
      ESP_LOGI(TAG, "Simulation duration of %d minutes reached. Stopping "
                    "simulation task.",
               SIMULATION_DURATION_MINUTES);
      // Az utolsó impulzus ideje már be van állítva, az inaktivitás figyelő
      // innen számolhat.
      break; // Kilépés a while ciklusból
    }

    vTaskDelay(pdMS_TO_TICKS(delay_between_pulses_ms));

    // Ellenőrizzük újra az időt a vTaskDelay után, hogy ne generáljunk
    // impulzust, ha már lejárt az idő
    if ((esp_timer_get_time() - simulation_start_time_us) >=
        simulation_duration_us) {
      ESP_LOGI(TAG, "Simulation duration reached during delay. Stopping "
                    "simulation task.");
      break;
    }

    // Szimuláljuk az ISR működését
    pulseCount.fetch_add(1, std::memory_order_relaxed);
    lastPulseTimeUs.store(esp_timer_get_time(), std::memory_order_relaxed);

    // ESP_LOGD(TAG, "Simulated pulse. Count: %llu",
    // pulseCount.load(std::memory_order_relaxed));
  }

  ESP_LOGI(TAG, "REED Simulation task finished and self-deleted.");
  vTaskDelete(NULL); // Task törlése
}

// --- Main (app_main) ---
extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "Starting Wheel Sensor Application V3 (Corrected Sleep Logic)");

    // NVS inicializálása és handle megnyitása
    esp_err_t nvs_err = init_nvs();
    if (nvs_err != ESP_OK || g_nvs_handle == 0) { // Ellenőrizzük a handle-t is
        ESP_LOGE(TAG, "NVS initialization or handle opening failed! NVS features might not work. Halting.");
        // Itt dönthetünk úgy, hogy NVS nélkül nem megyünk tovább, vagy korlátozott módban.
        // Most leállítjuk a programot, mert az NVS kritikus.
        return;
    }

    // Teljes impulzusszám betöltése NVS-ből a pulseCount-ba
    uint64_t loaded_pulses_from_nvs = 0;
    load_total_pulses_from_nvs(&loaded_pulses_from_nvs);
    pulseCount.store(loaded_pulses_from_nvs, std::memory_order_relaxed);
    ESP_LOGI(TAG, "Initial pulseCount set to: %llu (from NVS)", loaded_pulses_from_nvs);

    esp_sleep_source_t wakeup_cause = esp_sleep_get_wakeup_cause();
    ESP_LOGW(TAG, "Wakeup cause: %d", wakeup_cause);
    switch (wakeup_cause) {
        case ESP_SLEEP_WAKEUP_EXT0:
        case ESP_SLEEP_WAKEUP_EXT1:
        case ESP_SLEEP_WAKEUP_TIMER:
        case ESP_SLEEP_WAKEUP_TOUCHPAD:
        case ESP_SLEEP_WAKEUP_ULP:
          ESP_LOGI(TAG, "Waking from configured deep sleep source. Daily trip "
                    "start count (%llu) preserved.",
               dailyTripStartPulseCount);
          bootCount++;
          ESP_LOGI(TAG, "Boot count incremented to %d.", bootCount);    
          break;

    default:
      bootCount = 0;
      ESP_LOGI(TAG, "Cold boot or unexpected reset detected. Setting daily "
                    "trip start pulse count.");
      dailyTripStartPulseCount = pulseCount.load(std::memory_order_relaxed);
      lastPulseTimeUs.store(0, std::memory_order_relaxed);
      break;
    }

    // Mutex létrehozása
    xDataMutex = xSemaphoreCreateMutex();
    if (xDataMutex == NULL) {
        ESP_LOGE(TAG, "Failed to create data mutex! Halting.");
        // NVS handle bezárása, ha meg volt nyitva
        if (g_nvs_handle) nvs_close(g_nvs_handle);
        return;
    }

    // --- GPIO Konfiguráció ---
    // REED Switch (GPIO32)
    gpio_config_t io_conf_reed = {};
    io_conf_reed.intr_type = GPIO_INTR_NEGEDGE;
    io_conf_reed.pin_bit_mask = (1ULL << REED_SWITCH_PIN);
    io_conf_reed.mode = GPIO_MODE_INPUT;
    io_conf_reed.pull_up_en = GPIO_PULLUP_ENABLE;
    gpio_config(&io_conf_reed);
    ESP_LOGI(TAG, "REED GPIO %d configured.", REED_SWITCH_PIN);

    // Ébresztő Button (GPIO0)
    gpio_config_t io_conf_button = {};
    io_conf_button.pin_bit_mask = (1ULL << BUTTON_PIN);
    io_conf_button.mode = GPIO_MODE_INPUT;
    io_conf_button.pull_up_en = GPIO_PULLUP_ENABLE;
    gpio_config(&io_conf_button);
    ESP_LOGI(TAG, "Wakeup Button GPIO %d configured.", BUTTON_PIN);

    // Napi út nullázó Reset Button (GPIO35)
    // FONTOS: GPIO34-39 nem rendelkezik belső pull-up/pull-down ellenállásokkal!
    // KÜLSŐ PULL-UP ELLENÁLLÁS SZÜKSÉGES (pl. 10k a GPIO35 és 3.3V között).
    gpio_config_t io_conf_reset_btn = {};
    io_conf_reset_btn.pin_bit_mask = (1ULL << RESET_DAILY_BTN_PIN);
    io_conf_reset_btn.mode = GPIO_MODE_INPUT;
    io_conf_reset_btn.pull_up_en = GPIO_PULLUP_DISABLE; // Nincs belső, külsőt használunk
    io_conf_reset_btn.pull_down_en = GPIO_PULLDOWN_DISABLE;
    gpio_config(&io_conf_reset_btn);
    ESP_LOGI(TAG, "Reset Daily Button GPIO %d configured (EXTERNAL PULL-UP NEEDED!).", RESET_DAILY_BTN_PIN);


    // Globális GPIO ISR szolgáltatás telepítése
#if SIMULATE_REED_INPUT == 0
    esp_err_t isr_err = gpio_install_isr_service(0); // Default flags
     if (isr_err != ESP_OK && isr_err != ESP_ERR_INVALID_STATE) { // ESP_ERR_INVALID_STATE: már telepítve van
        ESP_LOGE(TAG, "Failed to install GPIO ISR service: %s. Halting.", esp_err_to_name(isr_err));
        if (g_nvs_handle) nvs_close(g_nvs_handle);
        vSemaphoreDelete(xDataMutex);
        return;
    } else if (isr_err == ESP_ERR_INVALID_STATE) {
         ESP_LOGW(TAG, "GPIO ISR service already installed.");
    } else {
         ESP_LOGI(TAG, "GPIO ISR service installed successfully.");
    }

    // ISR handler hozzáadása a REED pinhez
    isr_err = gpio_isr_handler_add(REED_SWITCH_PIN, gpio_isr_handler, (void*) REED_SWITCH_PIN);
     if (isr_err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to add ISR handler for REED GPIO %d: %s. Halting.", REED_SWITCH_PIN, esp_err_to_name(isr_err));
        if (g_nvs_handle) nvs_close(g_nvs_handle);
        vSemaphoreDelete(xDataMutex);
        // Lehet, hogy a gpio_uninstall_isr_service()-t is hívni kellene itt
        return;
    } else {
         ESP_LOGI(TAG, "ISR handler added for REED GPIO %d", REED_SWITCH_PIN);
    }
#else
  ESP_LOGW(TAG, "REED Simulation is ACTIVE. Real REED ISR is NOT attached.");
#endif
    // Taskok létrehozása
    BaseType_t task_created;
    task_created = xTaskCreate(calculation_and_control_task, "calc_ctrl_task", 4096, NULL, 5, NULL);
    if (task_created != pdPASS) { ESP_LOGE(TAG, "Failed to create calculation_and_control_task! Halting."); /* Cleanup... */ return; }

    task_created = xTaskCreate(serial_output_task, "serial_task", 4096, NULL, 4, NULL);
    if (task_created != pdPASS) { ESP_LOGE(TAG, "Failed to create serial_output_task! Halting."); /* Cleanup... */ return; }

    task_created = xTaskCreate(nvs_save_task, "nvs_save_task", 4096, NULL, 3, NULL);
    if (task_created != pdPASS) { ESP_LOGE(TAG, "Failed to create nvs_save_task! Halting."); /* Cleanup... */ return; }

    task_created = xTaskCreate(reset_button_monitor_task, "reset_btn_task", 2048, NULL, 6, NULL);
    if (task_created != pdPASS) { ESP_LOGE(TAG, "Failed to create reset_button_monitor_task! Halting."); /* Cleanup... */ return; }

    task_created = xTaskCreate(guiTask, "TFT task", 4096, NULL, 6, NULL);
    if (task_created != pdPASS) { ESP_LOGE(TAG, "Failed to create TFT task! Halting."); /* Cleanup... */ return; }

#if SIMULATE_REED_INPUT == 1
    task_created = xTaskCreate(reed_simulation_task, "reed_sim_task", 2048,
                               NULL, 4, NULL); // Prioritás beállítása
    if (task_created != pdPASS) {
      ESP_LOGE(TAG, "Failed to create REED simulation task! Halting.");
      // Cleanup...
      return;
    } else {
      ESP_LOGI(TAG, "REED Simulation task created.");
    }
#endif

    ESP_LOGI(TAG, "Initialization complete. Tasks are running.");
    // Az app_main itt véget érhet, a FreeRTOS scheduler futtatja a taskokat.
    // Az NVS handle nyitva marad, amíg a program fut, és alvás előtt bezáródik.
    // A bootCount-ot nem kell menteni alvás előtt, mert az RTC_DATA_ATTR változó
    vTaskDelay(pdMS_TO_TICKS(100));

}